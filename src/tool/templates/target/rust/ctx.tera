pub trait {{ctx_name.2}}Context: ToRule {
  {% for item in nonterminal_list %}
  fn {{item.0}}_list(&self) -> Vec<&dyn {{item.2}}Context>;{% endfor %}

  {% for item in terminal_list %}
  fn {{item.0}}_list(&self) -> Vec<&TerminalContext>;{% endfor %}

  {% for item in nonterminal %}
  fn {{item.0}}(&self) -> Option<&dyn {{item.2}}Context>;{% endfor %}

  {% for item in terminal %}
  fn {{item.0}}(&self) -> Option<&TerminalContext>;{% endfor %}

  fn accept(&self, visitor: &mut dyn {{grammar_name.2}}Visitor) -> Result<Box<dyn Any>, Box<dyn Error>>;
  fn enter(&self, listener: &mut dyn {{grammar_name.2}}Listener);
  fn exit(&self, listener: &mut dyn {{grammar_name.2}}Listener);
}

impl {{ ctx_name.2 }}Context for RuleContext {

  {% for item in nonterminal_list %}
  fn {{item.0}}_list(&self) -> Vec<&dyn {{item.2}}Context> {
    self.get_rule_contexts({{grammar_name.2}}Parser::{{item.1}}).iter().map(|ctx| *ctx as &dyn {{item.2}}Context).collect::<Vec<_>>()
  } {% endfor %}

  {% for item in terminal_list %}
  fn {{item.0}}_list(&self) -> Vec<&TerminalContext> {
    self.get_terminals({{grammar_name.2}}Lexer::{{item.1}})
  } {% endfor %}

  {% for item in nonterminal %}
  fn {{item.0}}(&self) -> Option<&dyn {{item.2}}Context> {
    self.get_rule_context({{grammar_name.2}}Parser::{{item.1}}, 0).map(|ctx| ctx as &dyn {{item.2}}Context)
  } {% endfor %}

  {% for item in terminal %}
  fn {{item.0}}(&self) -> Option<&TerminalContext> {
    self.get_terminal({{grammar_name.2}}Lexer::{{item.1}}, 0)
  } {% endfor %}


  fn accept(&self, visitor: &mut dyn {{grammar_name.2}}Visitor) -> Result<Box<dyn Any>, Box<dyn Error>> {
    visitor.visit_{{ ctx_name.0 }}(self)
  }

  fn enter(&self, listener: &mut dyn {{grammar_name.2}}Listener) {
    listener.enter_{{ ctx_name.0 }}(self)
  }

  fn exit(&self, listener: &mut dyn {{grammar_name.2}}Listener) {
    listener.exit_{{ ctx_name.0 }}(self)
  }
}
